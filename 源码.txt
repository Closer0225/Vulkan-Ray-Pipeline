if (hitValue.foundNeighbors >= 3)
	{
		vec3 cenpoint = vec3(0.f, 0.f, 0.f);
		for (int i = 0; i <hitValue.foundNeighbors; ++i)
			cenpoint = cenpoint + pointBuffer.queries[hitValue.optixIndices[i]];
		vec3 center = cenpoint /hitValue.foundNeighbors;
		//23.5ms
			
		vec3 dpoint=vec3(0.0,0.0,0.0);
		float dx2 = 0, dxy = 0, dxz = 0, dy2 = 0, dyz = 0, dz2 = 0;
        vec3  d;
		for (int i = 0; i < hitValue.foundNeighbors; i++) {
            dpoint = pointBuffer.queries[hitValue.optixIndices[i]];
            d = dpoint - center;
            dx2 += d.x * d.x;  dxy += d.x * d.y;
            dxz += d.x * d.z;  dy2 += d.y * d.y;
            dyz += d.y * d.z;  dz2 += d.z * d.z;
        }
		float matrix[6];
		matrix[0] = dx2;
		matrix[1] = dxy;
		matrix[2] = dxz;
		matrix[3] = dy2;
		matrix[4] = dyz;
		matrix[5] = dz2;

		mat3 tmp,vec_tmp,evecs;
		vec3 evals;
		normalBuffer.normals[idx]=compute(matrix,tmp, vec_tmp, evecs, evals);
		vec3 normal=normalBuffer.normals[idx];
		if (length(normal) > 0.5f)
            hitValue.query = hitValue.query + normal * dot(normal, center - pointBuffer.queries[idx]);
		//36.5ms
			
		if (order > 1)
        {
            vec3 plane_normal = normal;
            vec3 v_axis = unitOrthogonal(plane_normal);
            vec3 u_axis = cross(plane_normal, v_axis);
            float search_radius = hitValue.maxDistElemf;

            int num_neighbors = hitValue.foundNeighbors;
            if (order > 1)
            {

                if (num_neighbors >= nr_coeff)
                {
                    float weight_vec[maxresult];
                    float P[nr_coeff * maxresult];
                    float f_vec[maxresult];
					for(int i=0;i<nr_coeff*nr_coeff;i++) P_weight_Pt[i]=0;
                    vec3 de_meaned[maxresult];
                    for (int ni = 0; ni < num_neighbors; ++ni)
                    {
                        de_meaned[ni] = pointBuffer.queries[hitValue.optixIndices[ni]]- hitValue.query;//mean定义在computeNormal中的center
                        weight_vec[ni] = weight_func(dot(de_meaned[ni], de_meaned[ni]), search_radius);//移植一个weight_func()函数
                    }
						
                    //遍历邻居，在局部坐标系中转换它们，保存高度和多项式项的值
                    for (int ni = 0; ni < num_neighbors; ++ni)
                    {
                        //转换坐标
                        const float u_coord = dot(de_meaned[ni], u_axis);
                        const float v_coord = dot(de_meaned[ni], v_axis);
                        f_vec[ni] = dot(de_meaned[ni], plane_normal);
                        //计算多项式在当前点的项
                        int j = 0;
                        float u_pow = 1;
                        for (int ui = 0; ui <= order; ++ui)
                        {
                            float v_pow = 1;
                            for (int vi = 0; vi <= order - ui; ++vi, j++)
                            {
                                P[j * maxresult + ni] = u_pow * v_pow;
                                v_pow *= v_coord;
                            }
                            u_pow *= u_coord;
                        }
                    }
							
					float P_weight[nr_coeff * maxresult];
					for (int i = 0; i < nr_coeff; i++)
						for (int j = 0; j < num_neighbors; j++)
							P_weight[i * maxresult + j] = P[i * maxresult + j] * weight_vec[j];
						
					for (int i = 0; i < nr_coeff; i++)
						for (int j = 0; j < nr_coeff; j++)
							for(int k = 0;k <num_neighbors;k++)
								P_weight_Pt[i * nr_coeff + j] += P_weight[i * maxresult + k] * P[j * maxresult + k]; 

					for(int i=0;i<nr_coeff;i++)c_vec[i]=0;
                    for (int i = 0; i < nr_coeff; i++)
						for (int j = 0; j < num_neighbors; j++)
								c_vec[i] += P_weight[i * maxresult + j] * f_vec[j];

					initSymmetricMatrix(nr_coeff);
					bool isllt=llt();
					if(isllt){
						solveInPlace();
						hitValue.query = hitValue.query + (normal * c_vec[0]);
                        vec3 proj_normal = plane_normal - u_axis * c_vec[order + 1] - v_axis * c_vec[1];
                        proj_normal=normalized(proj_normal);
                        normal = proj_normal;
					}
				}
			}		
		}
		normalBuffer.normals[idx]=normal;
	}